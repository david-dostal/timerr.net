{"version":3,"sources":["../../scripts/common/interval-timer.js"],"names":["IntervalTimer","onTick","interval","reset","_running","currentTime","Date","getTime","expected","_startTime","actual","error","correctedInterval","_timerId","setTimeout","_tick","offset","_pauseTime","clearTimeout","elapsedTick","remainingTick","start"],"mappings":";;;;;;AAAA;;;;IAIMA,a;AACF,2BAAYC,MAAZ,EAAoBC,QAApB,EAA8B;AAAA;;AAC1B,aAAKD,MAAL,GAAcA,MAAd;AACA,aAAKC,QAAL,GAAgBA,QAAhB;AACA,aAAKC,KAAL;AACH;;;;gCAEO;AAAA;;AACJ,gBAAI,KAAKC,QAAT,EAAmB;AACf,qBAAKH,MAAL;;AAEA,oBAAII,cAAc,IAAIC,IAAJ,GAAWC,OAAX,EAAlB;AACA,oBAAIC,WAAW,KAAKC,UAAL,GAAkB,KAAKP,QAAtC;AACA,oBAAIQ,SAASL,cAAc,KAAKH,QAAhC;AACA,oBAAIS,QAAQD,SAASF,QAArB;AACA,oBAAII,oBAAoB,KAAKV,QAAL,GAAgBS,KAAxC;AACA;;AAEA,qBAAKE,QAAL,GAAgBC,WAAW;AAAA,2BAAM,MAAKC,KAAL,EAAN;AAAA,iBAAX,EAA+BH,iBAA/B,CAAhB;AACH;AACJ;;;gCAEiB;AAAA;;AAAA,gBAAZI,MAAY,uEAAH,CAAG;;AACd,iBAAKZ,QAAL,GAAgB,IAAhB;AACA,iBAAKK,UAAL,GAAkB,IAAIH,IAAJ,GAAWC,OAAX,KAAuBS,MAAzC;AACA,iBAAKH,QAAL,GAAgBC,WAAW;AAAA,uBAAM,OAAKC,KAAL,EAAN;AAAA,aAAX,EAA+BC,MAA/B,CAAhB;AACH;;;gCAEO;AACJ,iBAAKZ,QAAL,GAAgB,KAAhB;AACA,iBAAKa,UAAL,GAAkB,IAAIX,IAAJ,GAAWC,OAAX,EAAlB;AACAW,yBAAa,KAAKL,QAAlB;AACH;;;iCAEQ;AACL,iBAAKT,QAAL,GAAgB,IAAhB;AACA,gBAAIe,cAAc,CAAC,KAAKF,UAAL,GAAkB,KAAKR,UAAxB,IAAsC,KAAKP,QAA7D;AACA,gBAAIkB,gBAAgB,KAAKlB,QAAL,GAAgBiB,WAApC;AACA,iBAAKE,KAAL,CAAWD,aAAX;AACH;;;gCAEO;AACJ,iBAAKhB,QAAL,GAAgB,KAAhB;AACA,iBAAKS,QAAL,GAAgB,IAAhB;AACA,iBAAKJ,UAAL,GAAkB,IAAlB;AACA,iBAAKQ,UAAL,GAAkB,IAAlB;AACAC,yBAAa,KAAKL,QAAlB;AACH","file":"interval-timer.js","sourcesContent":["/* Repeatedly calls a function at given intervals in decomposeTime.\r\nSelf-corrects to generally stay in sync despite of timing inconsistencies.\r\nSkips executing the callback if the previous call hasn't finished yet. */\r\n\r\nclass IntervalTimer {\r\n    constructor(onTick, interval) {\r\n        this.onTick = onTick;\r\n        this.interval = interval;\r\n        this.reset();\r\n    }\r\n\r\n    _tick() {\r\n        if (this._running) {\r\n            this.onTick();\r\n\r\n            let currentTime = new Date().getTime();\r\n            let expected = this._startTime % this.interval;\r\n            let actual = currentTime % this.interval;\r\n            let error = actual - expected;\r\n            let correctedInterval = this.interval - error;\r\n            //console.log(\"decomposeTime: \" + new Date(currentTime).getMilliseconds().toString() + \" error: \" + error.toString() + \" interval: \" + correctedInterval.toString());\r\n\r\n            this._timerId = setTimeout(() => this._tick(), correctedInterval);\r\n        }\r\n    }\r\n\r\n    start(offset = 0) {\r\n        this._running = true;\r\n        this._startTime = new Date().getTime() + offset;\r\n        this._timerId = setTimeout(() => this._tick(), offset);\r\n    }\r\n\r\n    pause() {\r\n        this._running = false;\r\n        this._pauseTime = new Date().getTime();\r\n        clearTimeout(this._timerId);\r\n    }\r\n\r\n    resume() {\r\n        this._running = true;\r\n        let elapsedTick = (this._pauseTime - this._startTime) % this.interval;\r\n        let remainingTick = this.interval - elapsedTick;\r\n        this.start(remainingTick);\r\n    }\r\n\r\n    reset() {\r\n        this._running = false;\r\n        this._timerId = null;\r\n        this._startTime = null;\r\n        this._pauseTime = null;\r\n        clearTimeout(this._timerId);\r\n    }\r\n}"]}